syntax = "proto3";

package ouroboroskv;

option go_package = "github.com/i5heu/ouroboros-kv";

// KvDataHashProto represents the metadata for stored data with chunk hashes
message KvDataHashProto {
  bytes key = 1;                    // Key of the content (hash.Hash as bytes)
  repeated bytes chunk_hashes = 2;  // Hashes of chunk payloads
  bytes parent = 3;                 // Key of the parent chunk
  int64 created = 4;                // Unix timestamp when the data was created
  repeated bytes aliases = 5;       // Aliases for the data
  bytes prev_version_hash = 6;      // Hash of the previous version (zero for originals)
  int64 version_id = 7;             // Unix time in milliseconds representing this version (0 for originals)
  int64 prev_version_id = 8;        // VersionID of the previous version (0 for originals)
  repeated VersionRefProto branches = 9; // Alternative branch heads from the same ancestor
}

// VersionRefProto captures a versioned reference with its hash and VersionID
message VersionRefProto {
  bytes hash = 1;
  int64 version_id = 2;
}

// SliceRecordProto represents a single Reed-Solomon slice persisted in the key-value store
message SliceRecordProto {
  bytes chunk_hash = 1;                   // Hash of the clear chunk
  bytes sealed_hash = 2;                  // Hash of the sealed chunk prior to RS encoding
  uint32 rs_data_slices = 3;              // Number of data slices in the originating stripe
  uint32 rs_parity_slices = 4;            // Number of parity slices in the originating stripe
  uint32 rs_slice_index = 5;              // Index of the slice within the stripe
  uint64 size = 6;                        // Size of the slice payload
  uint64 original_size = 7;               // Size of the sealed chunk before RS split
  bytes encapsulated_key = 8;             // ML-KEM encapsulated secret for the sealed chunk
  bytes nonce = 9;                        // AES-GCM nonce for encryption
  bytes payload = 10;                     // Slice payload after RS encoding
}
